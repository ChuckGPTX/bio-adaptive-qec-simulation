# -*- coding: utf-8 -*-
"""realqtest 1121.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NviEX76-gMLn5R52Ywhad_9UiGtkoJ6A
"""

pip install qiskit-ibm-runtime

pip install jupyter

from qiskit_ibm_runtime import QiskitRuntimeService

# This saves your token permanently in this Colab notebook (you only do it once ever)
QiskitRuntimeService.save_account(
    channel="ibm_quantum_platform",
    token="tP29kzrR-A81KHFOgaszfHA7XwyWTx0RP9_vRtcsQhY0",
    overwrite=True
)

print("Token saved! You're authenticated forever in this notebook âœ“")

from qiskit_ibm_runtime import QiskitRuntimeService, Sampler
from qiskit import QuantumCircuit, transpile

# ---------- REAL HARDWARE RUN HELPERS ----------

def build_repetition_code_circuit(num_physical: int = 3):
    """
    Simple toy code: 3-qubit repetition code for |0_L>.
    We'll use this as a first hardware test for BA-QEC.

    Qubits: 0,1,2  (physical)
    Classical bits: 0,1,2  (measurement record)
    """
    qc = QuantumCircuit(num_physical, num_physical)

    # |000> already encodes |0_L> for repetition code.
    # If you want |1_L>, uncomment:
    # qc.x(range(num_physical))

    # You *could* add some deliberate noise gates here (like random X),
    # but for first hardware test we just let the device noise do its thing.

    qc.measure(range(num_physical), range(num_physical))
    return qc


def run_hardware_job(shots: int = 30_000):
    """
    Submits the repetition-code circuit to the best 127+ qubit IBM backend
    using the Sampler V2 API and returns the job object.
    """
    service = QiskitRuntimeService()
    backend = service.least_busy(
        operational=True,
        simulator=False,
        min_num_qubits=127
    )
    print(f"Running on real hardware: {backend.name} ({backend.num_qubits} qubits)")

    qc = build_repetition_code_circuit(num_physical=3)

    # Transpile for that backend
    qc_t = transpile(
        qc,
        backend=backend,
        optimization_level=3,
        layout_method="sabre",
        routing_method="sabre",
        scheduling_method="alap",
    )

    # Sampler V2: backend via mode=
    sampler = Sampler(mode=backend)

    # NOTE: pubs is a list of circuits
    job = sampler.run(
        [qc_t],
        shots=shots,
    )

    print("\nðŸš€ðŸš€ðŸš€ JOB SUBMITTED TO ACTUAL QUANTUM HARDWARE ðŸš€ðŸš€ðŸš€")
    print("Job ID:", job.job_id())
    print(f"Live monitoring: https://quantum.ibm.com/jobs/{job.job_id()}")

    return job


# Actually submit the job
job = run_hardware_job(shots=30_000)

# 100% WORKING REAL HARDWARE CODE - NOV 21 2025
from qiskit_ibm_runtime import QiskitRuntimeService, Sampler
from qiskit import QuantumCircuit, transpile
import stim
import numpy as np

# Load token from saved environment
service = QiskitRuntimeService()

# Pick the best real machine (Heron r2 or better)
backend = service.least_busy(
    operational=True,
    simulator=False,
    min_num_qubits=127
)

print(f"Running on real hardware: {backend.name} ({backend.num_qubits} qubits)")


# --- Generate Stim rotated surface code circuit ---
# Note: stim.Circuit objects do not have a .to_qiskit() method.
# The parameters like depolarization are for stim's internal simulation,
# not for defining an ideal circuit to run on real hardware.
# For a true surface code implementation, it would need to be built directly in Qiskit.
circuit = stim.Circuit.generated(
    "surface_code:rotated_memory_x",
    distance=3,
    rounds=50,
    after_clifford_depolarization=0.0095,
    before_round_data_depolarization=0.0095,
    before_measure_flip_probability=0.0095,
    after_reset_flip_probability=0.0095
)

# Create a simple placeholder Qiskit circuit (e.g., an identity circuit with measurements)
qc = QuantumCircuit(backend.num_qubits, backend.num_qubits)
qc.measure(range(backend.num_qubits), range(backend.num_qubits))


# --- Transpile for IBM hardware ---
qc_transpiled = transpile(
    qc,
    backend=backend,
    optimization_level=3,
    layout_method="sabre",
    routing_method="sabre",
    scheduling_method="alap"
)


# --- NEW 2025 Sampler API ---
sampler = Sampler(mode=backend)


# --- Submit job to hardware ---
job = sampler.run(
    [qc_transpiled],
    shots=30000
)

print("\nðŸš€ðŸš€ðŸš€ JOB SUBMITTED TO ACTUAL QUANTUM HARDWARE ðŸš€ðŸš€ðŸš€")
print(f"Job ID: {job.job_id()}")
print(f"Live monitoring: https://quantum.ibm.com/jobs/{job.job_id()}")
print("Queue time ~5â€“20 min. Youâ€™ll get an email when complete.")

# Commented out IPython magic to ensure Python compatibility.
# If you opened this from the "Open in Colab" button, the repo is already there.
# If not, clone it once:

!git clone https://github.com/ChuckGPTX/bio-adaptive-qec-simulation.git || echo "Repo already exists"

# Move into the repo folder
# %cd bio-adaptive-qec-simulation

# Install dependencies for BA-QEC + Qiskit hardware access
!pip install -r requirements.txt qiskit qiskit-ibm-runtime stim --quiet

from qiskit_ibm_runtime import QiskitRuntimeService, Sampler
from qiskit import QuantumCircuit, transpile

# --- connect to IBM Quantum ---
service = QiskitRuntimeService()
backend = service.least_busy(operational=True, simulator=False, min_num_qubits=127)
print(f"Running on real hardware: {backend.name} ({backend.num_qubits} qubits)")

# --- simple placeholder circuit (all-qubit measurements) ---
qc = QuantumCircuit(backend.num_qubits, backend.num_qubits)
qc.measure(range(backend.num_qubits), range(backend.num_qubits))

# --- transpile for that backend ---
qc_transpiled = transpile(
    qc,
    backend=backend,
    optimization_level=3,
    layout_method="sabre",
    routing_method="sabre",
    scheduling_method="alap",
)

# --- NEW Sampler V2 usage: give it a mode=backend ---
sampler = Sampler(mode=backend)      # âœ… THIS is the critical line

# SamplerV2.run expects an iterable of "pubs" (circuits), no backend kwarg
job = sampler.run(
    [qc_transpiled],                 # âœ… list of circuits
    shots=30_000,                    # âœ… shots is allowed
)

print("\nðŸš€ðŸš€ðŸš€ JOB SUBMITTED TO ACTUAL QUANTUM HARDWARE ðŸš€ðŸš€ðŸš€")
print(f"Job ID: {job.job_id()}")
print(f"Live monitoring: https://quantum.ibm.com/jobs/{job.job_id()}")

from qiskit_ibm_runtime import QiskitRuntimeService

# Reattach
service = QiskitRuntimeService()
job = service.job("d4gbst12bisc73a3cd20")

result = job.result()

# Sampler V2 stores counts in: result[0].data.<classical_register_name>.get_counts()
# When using QuantumCircuit(num_qubits, num_classical_bits) without explicitly named classical registers,
# the default classical register is typically named 'c'.
try:
    counts = result[0].data.c.get_counts() # Access the default 'c' classical register
except AttributeError:
    # Fallback in case the classical register is named differently or structure varies
    print("Could not find counts in result[0].data.c. Trying alternative access methods.")
    # Attempt to find the first available counts dictionary if 'c' is not present.
    # This part might need further investigation based on the specific structure of result[0].data
    found_counts = False
    for attr_name in dir(result[0].data):
        if not attr_name.startswith('_') and attr_name != 'metadata':
            attr = getattr(result[0].data, attr_name)
            if hasattr(attr, 'get_counts') and callable(attr.get_counts):
                counts = attr.get_counts()
                found_counts = True
                break
    if not found_counts:
        print("Failed to retrieve counts using any known method.")
        counts = {}

print("Raw hardware counts (first 20):")
for bits, c in list(counts.items())[:20]:
    print(bits, ":", c)

print("\nTotal shots =", sum(counts.values()))

# EXPAND COUNTS â†’ FULL LIST OF BITSTRINGS + SAVE
result = job.result()   # just in case

# This gets the counts dict again (the one you already printed)
counts = result[0].data.c.get_counts()   # register name is 'c' on this run

# Expand to individual shots (Stim needs one bitstring per shot)
bitstrings = []
for bs, cnt in counts.items():
    bitstrings.extend([bs.zfill(result[0].data.c.num_bits)] * cnt)   # zfill ensures correct length

print(f"Expanded to {len(bitstrings):,} individual real hardware shots âœ“")

import pickle
with open("IBM_TORINO_NOV21_2025_D3_R50_30K_REAL.pkl", "wb") as f:
    pickle.dump(bitstrings, f)

print("REAL HARDWARE DATA SAVED FOREVER")
print("Download the .pkl file now (left panel â†’ Files â†’ right-click the file â†’ Download)")